{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"ResultValue/","title":"ResultValue","text":"<p>This class is a helper wrapper for values coming from a form Result. It provides a safer and convenient interface to render the contained value in various formats.  The main purpose is to avoid the need to check for null or undefined values while having a convenient interface to print the value in a template.</p>"},{"location":"ResultValue/#usage","title":"Usage","text":"<p>All the following examples assume that the form has been opened with the following templater code:</p> <pre><code>&lt;%* const result = await forms.openForm('myForm'); %&gt;\n</code></pre>"},{"location":"ResultValue/#renderprinting-as-string","title":"Render/printing as string","text":"<p>By default, the value is rendered as a string. If the value is null or undefined, an empty string is returned. You don't need to call or do anything special to render the value as a string, just use it as if it was a string.</p> <pre><code>&lt;% result.getValue('firstField') %&gt;\n</code></pre> <p>if the value of the field is \"Hello World\", the above code will print \"Hello World\" in the resulting note. However, if the value is null or undefined, nothing will be printed.</p>"},{"location":"ResultValue/#renderprinting-as-bullet-list","title":"Render/printing as bullet list","text":"<p>You can render any value as a bullet list by using the <code>toBulletList()</code> method. If the value is an array, each element of the array will be printed as a bullet point. If the value is a primitive, like a number or a string, it will be printed as a single bullet point. If the value is null or undefined, an empty string is printed.</p> <pre><code>&lt;% result.getValue('listField').toBulletList() %&gt;\n</code></pre> <p>You can also use a shorthand for this method by using the <code>bullets</code> property:</p> <pre><code>&lt;% result.getValue('listField').bullets %&gt;\n</code></pre> <p>The above code is equivalent to the previous one.</p> <p>If the value of the field is <code>[\"Hello\", \"World\"]</code>, the above code will print:</p> <pre><code>- Hello\n- World\n</code></pre>"},{"location":"ResultValue/#renderprinting-as-dataview-field","title":"Render/printing as dataview field","text":"<p>You can render any value as a dataview field by using the <code>toDataviewField()</code> method or the shorthand <code>toDv()</code> alias.</p> <p>List values are rendered as a dataview list field, while primitive values are just rendered as a dataview field.</p> <pre><code>&lt;% result.getValue('listField').toDataviewField() %&gt;\nOr alias:\n&lt;% result.getValue('listField').toDv() %&gt;\n</code></pre> <p>if the value of the field is <code>[\"Hello\", \"World\"]</code>, the above code will print:</p> <pre><code>[listField:: \"Hello\", \"World\"]\n</code></pre> <p>If the value were a primitive, like the string \"Hello World\", the above code would print:</p> <pre><code>[listField:: Hello World]\n</code></pre>"},{"location":"ResultValue/#mapfn-value-any-any-resultvalue-method","title":"<code>map(fn: (value: any) =&gt; any): ResultValue</code> method","text":"<p>The map method is a powerful one that allows you to transform the value contained in the ResultValue object without extracting it, allowing you to chain multiple transformations.</p> <pre><code>&lt;% result.getValue('listField').map((value) =&gt; value.toUpperCase()).bullets %&gt;\n</code></pre> <p>The above code will print the list field as a bullet list, but all the values will be uppercased.</p> <p>The map method takes a function that takes the value and returns a new value. It can be used when none of the provided printing are enough for your use case, or when one of them is almost what you need but you need to transform the value a bit more.</p>"},{"location":"ResultValue/#trimmedlowerupper-shortcuts","title":"<code>trimmed</code>,<code>lower</code>,<code>upper</code> shortcuts","text":"<p>The ResultValue class provides some shortcuts to common transformations of the value. They are:  - <code>trimmed</code>: Trims the value, removing any leading or trailing whitespace.  - <code>lower</code>: Converts the value to lowercase.  - <code>upper</code>: Converts the value to uppercase.</p> <p>All of these shortcuts return a new ResultValue object, so you can chain them with other methods.</p> <pre><code>&lt;% result.getValue('listField').trimmed.upper.bullets %&gt;\n</code></pre> <p>The above code will print the list field as a bullet list, but all the values will be uppercased and trimmed. You can chain as many or as little as you want. The most common use is probably just to use one of them, like <code>trimmed</code> or <code>upper</code>.</p> <pre><code>&lt;% result.getValue('myField').trimmed %&gt;\n</code></pre> <p>All of this shortcuts are able to handle single values and lists, so you can use them with any value.</p>"},{"location":"advanced-examples/","title":"Advanced usage examples","text":"<p>In this section of the docs you will find some advanced usage examples of modal-form-plugin</p>"},{"location":"advanced-examples/#nesting-form-calls","title":"Nesting form calls","text":""},{"location":"advanced-examples/#modifying-frontmatter-with-a-form","title":"Modifying frontmatter with a form","text":"<p>If you want to modify the content of a notes frontmatter with one of your existing forms, put the following snippet in a templater template, substituting the name of your form:</p> <pre><code>&lt;%*\n  const run = async (frontmatter) =&gt; {\n    const result = await tp.user.openForm('frontmatter', {\n      values: { ...frontmatter },\n    });\n    return result.getData();\n  };\n  //first we get the data from the form\n  const data = await run(tp.frontmatter);\n // Then we update the frontmatter with the new data\n  app.fileManager.processFrontMatter(\n    tp.config.target_file,\n    frontmatter =&gt; {\n      Object.assign(frontmatter, data);\n    },\n  );\n%&gt;\n\nPlease be aware that this is not atomic, so if if something edits the frontmatter while you are editing it within the form,\nthe form values will not reflect this change and you may be overwriting some changes. Although this is unlikely to happen, it is better to be aware of it.\n</code></pre> <p>The values the form understand and that are pressent in the frontmatter, will be populated with the values on the frontmatter. Then, when you submit the form, the new values will overwrite the old ones, leaving the rest untouched.</p>"},{"location":"advanced-examples/#making-calling-forms-more-convenient","title":"Making calling forms more convenient","text":"<p>If you are using templater, you can make calling forms more convenient by using the following snippet:</p> <pre><code>const modalForm = app.plugins.plugins.modalforms.api;\nmodule.exports = (formName, options) =&gt; modalForm.openForm(formName, options);\n</code></pre> <p>If you save this snippet as <code>openForm.js</code> in your templater snippets folder, then you can then call it like this from templater:</p> <pre><code>&lt;%*\nconst result = await tp.user.openForm('example-form', { values: { size: 'large' }});\n%&gt;\n</code></pre>"},{"location":"advanced-examples/#exclude-subfolders-when-selecting-notes-from-a-folder","title":"Exclude subfolders when selecting notes from a folder","text":"<p>Instead of using the <code>note</code> type or the <code>note</code> source (in case of multi-select) in your form, which doesn't support exclusions yet, we will use <code>dataview</code> (either type or as a multi-select source) to get the notes we want. Then use the following query to exclude subfolders:</p> <pre><code>dv.pages('\"Data\" AND -\"Data/Nested\"').file.name\n</code></pre> <p>Here <code>Data</code> is the folder we want to get notes from and <code>Data/Nested</code> is the subfolder we want to exclude. Please keep in mind that <code>dataview</code> is very sensitive to spaces and quotes. Removing the nested <code>\"</code> will not work, or adding a space after the <code>-</code> will not work either.</p>"},{"location":"managing-results/","title":"Managing Results","text":"<p>The <code>FormResult</code> class provides methods for accessing and formatting form results.</p> <p>[!TIP] From version <code>1.33.0</code> onwards, the <code>FormResult</code> class allows accessing the values of the form fields  using directly <code>property accessors</code>, like <code>result.title</code> or <code>result.listField</code>. The property accessors are equivalent to calling the <code>get</code> method, so <code>result.title</code> is equivalent to <code>result.get('title')</code>, but it's shorter and more convenient. All the examples in this page continue to use the more explicit ways to access the values, but you can use the property accessors if you prefer.</p> <p>[!IMPORTANT] Accessing the values using <code>property accessors</code> or the <code>getValue</code> method is considered the safer and preferred way to access the values. This is because the returned values are wrapped in a <code>ResultValue</code> object that provides a safer and more convenient interface to render the values in various formats.</p>"},{"location":"managing-results/#asfrontmatterstringoptions-unknown-string","title":"<code>asFrontmatterString(options?: unknown): string</code>","text":"<p>Transforms the current data into a frontmatter string, which is expected to be enclosed in <code>---</code> when used in a markdown file. This method does not add the enclosing <code>---</code> to the string, so you can put it anywhere inside the frontmatter.</p>"},{"location":"managing-results/#parameters","title":"Parameters","text":"<ul> <li> <p><code>options</code> (optional): An options object describing what options to pick or omit.</p> <ul> <li><code>pick</code> (optional): An array of key names to pick from the data.</li> <li><code>omit</code> (optional): An array of key names to omit from the data.</li> </ul> </li> </ul>"},{"location":"managing-results/#returns","title":"Returns","text":"<ul> <li><code>string</code>: The data formatted as a frontmatter string.</li> </ul>"},{"location":"managing-results/#example","title":"Example","text":"<pre><code>const result = await form.openForm(\"my-form\");\ntR += result.asFrontmatterString({ pick: [\"title\"] });\n</code></pre>"},{"location":"managing-results/#aliases","title":"Aliases","text":"<p>this method has the following aliases:</p> <ul> <li><code>asFrontmatter</code></li> <li><code>asYaml</code></li> </ul>"},{"location":"managing-results/#asdataviewpropertiesoptions-unknown-string","title":"<code>asDataviewProperties(options?: unknown): string</code>","text":"<p>Returns the current data as a block of dataview properties.</p>"},{"location":"managing-results/#parameters_1","title":"Parameters","text":"<ul> <li> <p><code>options</code> (optional): An options object describing what options to pick or omit.</p> <ul> <li><code>pick</code> (optional): An array of key names to pick from the data.</li> <li><code>omit</code> (optional): An array of key names to omit from the data.</li> </ul> </li> </ul>"},{"location":"managing-results/#returns_1","title":"Returns","text":"<ul> <li><code>string</code>: The data formatted as a block of dataview properties.</li> </ul>"},{"location":"managing-results/#example_1","title":"Example","text":"<pre><code>const result = await form.openForm('my-form')\ntR += result.asDataviewProperties({ pick: ['title'] });`\n</code></pre>"},{"location":"managing-results/#aliases_1","title":"Aliases","text":"<p>This method has the following aliases:</p> <ul> <li><code>asDataview</code></li> <li><code>asDv</code></li> </ul>"},{"location":"managing-results/#getkey-string-mapfn-value-any-any-any","title":"<code>get(key: string, mapFn?: (value: any) =&gt; any): any</code>","text":"<p>Returns the value of the given key. If the key does not exist, returns the empty string <code>\"\"</code>. It takes an optional map function that can be used to transform the value. If the key does not exist, the map function is not called.</p>"},{"location":"managing-results/#parameters_2","title":"Parameters","text":"<ul> <li><code>key</code>: The key to get the value of.</li> <li><code>mapFn</code> (optional): A function that takes the value and returns a new value.</li> </ul>"},{"location":"managing-results/#returns_2","title":"Returns","text":"<ul> <li><code>any</code>: The value of the given key.</li> </ul>"},{"location":"managing-results/#example_2","title":"Example","text":"<pre><code>const result = await form.openForm(\"my-form\");\ntR += result.get(\"title\");\n</code></pre> <p>Or with a map function:</p> <pre><code>const result = await form.openForm(\"my-form\");\ntR += result.get(\"title\", (value) =&gt; value.toUpperCase());\n</code></pre>"},{"location":"managing-results/#getvaluekey-string-resultvalue-or-getvkey-string-resultvalue","title":"<code>getValue(key: string): ResultValue</code> or <code>getV(key: string): ResultValue</code>","text":"<p>Returns the value of the given key as a <code>ResultValue</code> object.</p>"},{"location":"managing-results/#parameters_3","title":"Parameters","text":"<ul> <li><code>key</code>: The key to get the value of.</li> </ul>"},{"location":"managing-results/#returns_3","title":"Returns","text":"<ul> <li><code>ResultValue</code>: The value of the given key as a <code>ResultValue</code> object.  If the key field doesn't exist or is empty, returns an empty <code>ResultValue</code> object. Thanks to this, you don't need to check if the field exists or is empty because the <code>ResultValue</code> object will handle it for you.</li> </ul>"},{"location":"managing-results/#example_3","title":"Example","text":"<pre><code>const result = await form.openForm(\"my-form\");\ntR += result.getValue(\"title\");\ntR += result.getValue(\"listField\").bullets;\n</code></pre> <p>Thanks to <code>property accessors</code>, you can also write the above code in a more convenient way like this:</p> <pre><code>const result = await form.openForm(\"my-form\");\ntR += result.title;\ntR += result.listField.bullets;\n</code></pre> <p>For more details and examples, see the <code>ResultValue</code> documentation.</p>"}]}